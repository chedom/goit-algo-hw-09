# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування
---
## Теоретична складність

| Алгоритм                | Часова складність | Просторова складність |
|-------------------------|-------------------|-----------------------|
| Жадібний                | O(n)              | O(1)                  |
| Динамічне програмування | O(sum × n)        | O(sum)                |

де `n` — кількість номіналів монет, `sum` — цільова сума.

## Результати бенчмарку

| Сума  | Жадібний (с) | DP (с) | Різниця |
|-------|--------------|--------|---------|
| 19    | ~0.00005     | ~0.003 | ~60x    |
| 113   | ~0.00006     | ~0.018 | ~300x   |
| 589   | ~0.00006     | ~0.095 | ~1500x  |
| 1873  | ~0.00006     | ~0.30  | ~5000x  |
| 12891 | ~0.00006     | ~2.1   | ~35000x |

* важливо зазначити, що дані тестування можуть відрізнятись в залежності від конфігурації (CPU, RAM) ПК на якому запущене тестування та його навантаженості іншими конкурентними процесами.

## Аналіз результатів

### Жадібний алгоритм
**Переваги:**
- Надзвичайно швидкий — час виконання практично не залежить від суми
- Мінімальне використання пам'яті
- Простий у реалізації

**Недоліки:**
- Не гарантує оптимального рішення для всіх наборів монет
- Для деяких систем номіналів може давати неправильний результат (Для номіналів [1, 3, 4] і суми 6 поверне результат: {4: 1, 1: 2}, DP повертає {3: 2}, на 1 монету менше)

### Динамічне програмування
**Переваги:**
- Завжди знаходить мінімальну кількість монет
- Працює коректно для будь-якого набору номіналів

**Недоліки:**
- Час виконання лінійно зростає зі збільшенням суми
- Використовує O(sum) пам'яті, що може бути проблемою для дуже великих сум


## Висновки

1. **Для великих сум** жадібний алгоритм значно ефективніший — різниця в продуктивності зростає експоненціально.

2. **Для систем монет** (кожен більший номінал можна ефективно замінити меншими без втрати оптимальності) як наведена у домашньому завданні жадібний алгоритм є оптимальним вибором, оскільки він швидший і дає правильний результат.

3. **Для довільних наборів монет** необхідно використовувати динамічне програмування, яке гарантує мінімальну кількість монет.

4. **Компроміс**: Якщо швидкість критична і система монет така як у домашньому завданні (кожен більший номінал можна ефективно замінити меншими без втрати оптимальності) — необхідний жадібний алгоритм. Якщо потрібна гарантія оптимальності — динамічне програмування.
